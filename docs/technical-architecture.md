# Technical Architecture

## Overview

Personal Golf is a Progressive Web App (PWA) built with **Ruby on Rails 8**, designed as an open-source project for golfers to track and share tips, routines, and course knowledge. The architecture leverages Rails 8's "No PaaS Required" philosophy with the Solid trifecta (Queue, Cache, Cable) for simplified deployment and reduced dependencies.

## Tech Stack

### Full-Stack Framework

- **Framework**: Ruby on Rails 8
- **Language**: Ruby 3.2+
- **Frontend**: Hotwire (Turbo + Stimulus)
- **Styling**: Tailwind CSS
- **JavaScript**: Importmaps (no build step)
- **PWA**: Built-in Rails PWA support

### Database & Background Services

- **Primary Database**: SQLite (production-ready with Rails 8)
- **Background Jobs**: Solid Queue (database-backed)
- **Caching**: Solid Cache (database-backed)
- **Real-time**: Solid Cable (database-backed)
- **File Storage**: Active Storage with local file system

### External Services

- **AI**: Google Gemini API
- **Weather**: OpenWeatherMap API
- **Location**: Browser Geolocation API
- **Golf Data**: GHIN API integration
- **Wearables**: Apple Watch, Arccos integrations

### Infrastructure & Deployment

- **Deployment**: Kamal 2 (included by default)
- **Server**: Any Linux VPS ($5/month capable)
- **Web Server**: Puma + Thruster (HTTP/2, compression)
- **SSL**: Automatic via Kamal Proxy + Let's Encrypt
- **Monitoring**: Rails built-in logging + optional external
- **CI/CD**: GitHub Actions (generated by default)

## System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     CLIENT LAYER (PWA)                          │
├─────────────────────────────────────────────────────────────────┤
│  Rails Frontend (Hotwire)                                      │
│  ├── Turbo (SPA-like navigation)                               │
│  ├── Stimulus (JavaScript interactions)                        │
│  ├── Service Worker (offline/caching)                          │
│  ├── Web App Manifest                                          │
│  └── IndexedDB (offline storage)                               │
├─────────────────────────────────────────────────────────────────┤
│                    RAILS APPLICATION                            │
├─────────────────────────────────────────────────────────────────┤
│  Ruby on Rails 8 Application Server                            │
│  ├── Controllers (MVC + API endpoints)                         │
│  ├── Models (ActiveRecord + business logic)                    │
│  ├── Views (ERB + Turbo Streams)                               │
│  ├── Authentication (built-in Rails 8 generator)               │
│  ├── Mailers (password reset, notifications)                   │
│  └── Jobs (background processing)                              │
├─────────────────────────────────────────────────────────────────┤
│                    SOLID TRIFECTA                               │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ │
│  │ Solid Queue │  │ Solid Cache │  │     Solid Cable         │ │
│  │ (Jobs)      │  │ (Caching)   │  │   (WebSockets)          │ │
│  │             │  │             │  │                         │ │
│  │ - AI Tips   │  │ - Page Cache│  │ - Real-time updates     │ │
│  │ - Emails    │  │ - Fragment  │  │ - Tip notifications     │ │
│  │ - Analytics │  │ - Query     │  │ - Live course updates   │ │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     SQLITE DATABASE                             │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐ │
│  │   App Data   │  │ Queue Tables │  │    Cache Tables      │ │
│  │              │  │              │  │                      │ │
│  │ • Users      │  │ • Jobs       │  │ • Cache entries      │ │
│  │ • Tips       │  │ • Executions │  │ • Fragment cache     │ │
│  │ • Courses    │  │ • Recurring  │  │ • Query cache        │ │
│  │ • Sessions   │  │              │  │                      │ │
│  └──────────────┘  └──────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    EXTERNAL SERVICES                            │
├─────────────────────────────────────────────────────────────────┤
│  AI & Integration Services                                      │
│  ├── Google Gemini API (tip generation)                        │
│  ├── OpenWeatherMap (course conditions)                        │
│  ├── Browser APIs (GPS, notifications)                         │
│  └── Future: GHIN, Apple Watch, Arccos                         │
└─────────────────────────────────────────────────────────────────┘
```

## Data Models

### Core Rails Models

```ruby
# User authentication and profile
class User < ApplicationRecord
  has_secure_password
  has_many :sessions, dependent: :destroy
  has_many :tips, dependent: :destroy
  has_many :saves, dependent: :destroy
  has_many :saved_tips, through: :saves, source: :tip

  validates :email, presence: true, uniqueness: true
  normalizes :email, with: ->(email) { email.strip.downcase }

  generates_token_for :password_reset, expires_in: 15.minutes
end

# Golf tips content
class Tip < ApplicationRecord
  belongs_to :user
  belongs_to :category
  has_many :saves, dependent: :destroy
  has_many :saved_by_users, through: :saves, source: :user
  has_many_attached :images

  validates :title, :content, presence: true

  enum phase: { pre_round: 0, during_round: 1, post_round: 2 }
  enum skill_level: { beginner: 0, intermediate: 1, advanced: 2 }

  scope :popular, -> { order(save_count: :desc) }
  scope :recent, -> { order(created_at: :desc) }

  # Real-time updates via Turbo Streams
  broadcasts_to :category

  # Background job for AI analysis
  after_create_commit :analyze_content_async

  private

  def analyze_content_async
    AnalyzeTipContentJob.perform_later(self)
  end
end

# Golf courses
class Course < ApplicationRecord
  has_many :tips, dependent: :destroy
  has_many :holes, dependent: :destroy
  has_many_attached :photos

  validates :name, :location, presence: true

  # Full-text search
  include PgSearch::Model
  pg_search_scope :search_content,
    against: [:name, :location, :description]
end

# User's saved tips
class Save < ApplicationRecord
  belongs_to :user
  belongs_to :tip, counter_cache: :save_count

  validates :user_id, uniqueness: { scope: :tip_id }
end
```

## Key Features Implementation

### PWA & Offline Functionality

```ruby
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  # PWA offline support
  before_action :set_pwa_headers

  private

  def set_pwa_headers
    response.headers['Cache-Control'] = 'no-cache' if request.format.html?
  end
end

# Service Worker for offline support
# app/views/layouts/application.html.erb
<%= javascript_importmap_tags %>
<%= turbo_include_tags %>
<%= stimulus_include_tags %>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js');
  }
</script>
```

### Background Jobs with Solid Queue

```ruby
# Generate AI-powered tips
class GeneratePersonalizedTipsJob < ApplicationJob
  queue_as :ai_generation

  def perform(user_id, category)
    user = User.find(user_id)

    # Call Gemini API
    response = GeminiService.generate_tip(
      user_profile: user.profile_data,
      category: category
    )

    # Create tip and broadcast to user
    tip = user.tips.create!(
      title: response[:title],
      content: response[:content],
      category: category,
      ai_generated: true
    )

    # Real-time notification via Turbo Stream
    broadcast_append_to user, target: "tips", partial: "tips/tip", locals: { tip: tip }
  end
end

# Email notifications
class TipNotificationJob < ApplicationJob
  queue_as :notifications

  def perform(tip_id)
    tip = Tip.find(tip_id)

    # Find users interested in this category
    interested_users = User.joins(:preferences)
                          .where(preferences: { category: tip.category })

    interested_users.find_each do |user|
      TipMailer.new_tip_notification(user, tip).deliver_now
    end
  end
end
```

### Real-time Features with Solid Cable

```ruby
# app/channels/tips_channel.rb
class TipsChannel < ApplicationCable::Channel
  def subscribed
    stream_from "tips_#{params[:category]}"
    stream_from "user_#{current_user.id}_tips"
  end

  def receive(data)
    case data['action']
    when 'save_tip'
      tip = Tip.find(data['tip_id'])
      current_user.saves.create!(tip: tip)

      broadcast_to "tips_#{tip.category}", {
        type: 'tip_saved',
        tip_id: tip.id,
        save_count: tip.reload.save_count
      }
    end
  end
end

# Real-time tip updates in models
class Tip < ApplicationRecord
  after_update_commit :broadcast_changes

  private

  def broadcast_changes
    broadcast_update_to category, target: "tip_#{id}"
  end
end
```

### Caching with Solid Cache

```ruby
# app/controllers/tips_controller.rb
class TipsController < ApplicationController
  def index
    @tips = Rails.cache.fetch("tips_#{params[:category]}_#{current_user.id}", expires_in: 5.minutes) do
      Tip.includes(:user, :category)
         .where(category: params[:category])
         .popular
         .limit(20)
         .to_a
    end
  end

  def show
    @tip = Rails.cache.fetch("tip_#{params[:id]}", expires_in: 1.hour) do
      Tip.includes(:user, :saves, images_attachments: :blob)
         .find(params[:id])
    end
  end
end

# Fragment caching in views
# app/views/tips/_tip.html.erb
<%= cache tip do %>
  <div class="tip-card" data-tip-id="<%= tip.id %>">
    <h3><%= tip.title %></h3>
    <p><%= tip.content %></p>
    <!-- ... rest of tip HTML ... -->
  </div>
<% end %>
```

## Security & Privacy

### Authentication (Rails 8 Built-in)

```ruby
# Generated by: rails generate authentication

# app/models/user.rb
class User < ApplicationRecord
  has_secure_password
  has_many :sessions, dependent: :destroy

  validates :email, presence: true, uniqueness: true
  normalizes :email, with: ->(email) { email.strip.downcase }

  generates_token_for :password_reset, expires_in: 15.minutes
end

# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def create
    if user = User.authenticate_by(email: params[:email], password: params[:password])
      login user
      redirect_to root_path
    else
      flash.now[:alert] = "Invalid email or password"
      render :new, status: :unprocessable_entity
    end
  end
end
```

### Authorization & Content Moderation

```ruby
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  before_action :authenticate_user!

  private

  def authenticate_user!
    redirect_to login_path unless user_signed_in?
  end

  def current_user
    Current.user ||= authenticate_user_from_session
  end

  def authenticate_user_from_session
    User.find_by(id: session[:user_id]) if session[:user_id]
  end
end

# Content moderation
class Tip < ApplicationRecord
  before_create :moderate_content

  private

  def moderate_content
    # Basic content filtering
    self.flagged = true if content.include?('inappropriate_word')

    # Queue for manual review if flagged
    ModerationJob.perform_later(self) if flagged?
  end
end
```

## External API Integration

### Gemini AI Integration

```ruby
# app/services/gemini_service.rb
class GeminiService
  include HTTParty
  base_uri 'https://generativelanguage.googleapis.com'

  def self.generate_tip(user_profile:, category:)
    prompt = build_prompt(user_profile, category)

    response = post('/v1/models/gemini-pro:generateContent',
      headers: {
        'Content-Type' => 'application/json',
        'x-goog-api-key' => Rails.application.credentials.gemini_api_key
      },
      body: {
        contents: [{ parts: [{ text: prompt }] }]
      }.to_json
    )

    parse_response(response)
  end

  private

  def self.build_prompt(user_profile, category)
    "Generate a personalized golf tip for a #{user_profile[:skill_level]} golfer
     focusing on #{category}. User's handicap: #{user_profile[:handicap]}.
     Make it practical and actionable in 2-3 sentences."
  end

  def self.parse_response(response)
    content = response.dig('candidates', 0, 'content', 'parts', 0, 'text')

    {
      title: content.lines.first&.strip || 'Golf Tip',
      content: content
    }
  end
end
```

## Development Workflow

### Repository Structure

```
personal-golf/
├── app/                       # Rails application
│   ├── controllers/           # MVC controllers
│   ├── models/               # ActiveRecord models
│   ├── views/                # ERB templates
│   ├── jobs/                 # Background jobs
│   ├── services/             # Business logic services
│   ├── channels/             # Action Cable channels
│   └── mailers/              # Email templates
├── config/                   # Rails configuration
├── db/                       # Database migrations & seeds
├── public/                   # Static assets & PWA files
├── lib/                      # Custom libraries
├── test/                     # Test suite
├── script/                   # One-off scripts
├── docs/                     # Documentation
└── config/deploy.yml         # Kamal deployment config
```

### Deployment with Kamal 2

```yaml
# config/deploy.yml (generated by Rails 8)
service: personal-golf
image: your-registry/personal-golf

servers:
  web:
    - 192.168.1.100

registry:
  server: ghcr.io
  username: jeffreythomas
  password:
    - GITHUB_TOKEN

env:
  clear:
    RAILS_LOG_LEVEL: info
  secret:
    - RAILS_MASTER_KEY
    - GEMINI_API_KEY
# Deploy with: kamal deploy
```

## Performance Considerations

### Database Optimization

```ruby
# Database indexes for common queries
class AddIndexesToTips < ActiveRecord::Migration[8.0]
  def change
    add_index :tips, [:category_id, :created_at]
    add_index :tips, [:user_id, :created_at]
    add_index :tips, :save_count
    add_index :saves, [:user_id, :tip_id], unique: true
  end
end

# Query optimization
class Tip < ApplicationRecord
  scope :popular_in_category, ->(category) do
    where(category: category)
      .includes(:user, :category)
      .order(save_count: :desc, created_at: :desc)
  end
end
```

### Frontend Performance

```erb
<!-- Lazy loading images -->
<%= image_tag tip.featured_image,
    loading: :lazy,
    class: "tip-image",
    sizes: "(max-width: 768px) 100vw, 50vw" %>

<!-- Turbo Frame for partial updates -->
<%= turbo_frame_tag "tip_#{tip.id}" do %>
  <%= render tip %>
<% end %>
```

## Monitoring & Analytics

```ruby
# config/application.rb
config.solid_cache.store_options = {
  max_size: 256.megabytes,
  max_entries: 10_000
}

# Basic logging
Rails.logger.info "Tip generated for user #{user.id}: #{tip.title}"

# Performance monitoring
class ApplicationController < ActionController::Base
  around_action :log_performance

  private

  def log_performance
    start_time = Time.current
    yield
    duration = Time.current - start_time
    Rails.logger.info "#{request.path} completed in #{duration.round(2)}s"
  end
end
```

## Future Considerations

### iOS Native App

- **Approach**: Turbo Native for iOS
- **Code Reuse**: 95%+ shared with web app
- **Native Features**: Push notifications, Apple Watch integration

### Scaling Strategy

- **Database**: Consider PostgreSQL for high traffic
- **Background Jobs**: Dedicated job servers with Solid Queue
- **Caching**: Redis for high-performance scenarios
- **CDN**: CloudFlare for global asset delivery

### Integration Roadmap

1. **Phase 1**: Weather API, GPS integration
2. **Phase 2**: GHIN handicap sync
3. **Phase 3**: Apple Watch companion app
4. **Phase 4**: Arccos/shot tracking integration
